// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/cdk.json
{
  "app": "npx ts-node --prefer-ts-exts src/bin/minibus-backend-aws-cdk.ts",
  "watch": {
    "include": ["**"],
    "exclude": [
      "README.md",
      "cdk*.json",
      "***.js",
      "tsconfig.json",
      "package*.json",
      "yarn.lock",
      "node_modules",
      "test"
    ]
  },
  "context": {
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/core:checkSecretUsage": true,
    "@aws-cdk/core:target-partitions": ["aws", "aws-cn"],
    "@aws-cdk-containers/ecs-service-extensions:enableDefaultLogDriver": true,
    "@aws-cdk/aws-ec2:uniqueImdsv2TemplateName": true,
    "@aws-cdk/aws-ecs:arnFormatIncludesClusterName": true,
    "@aws-cdk/aws-iam:minimizePolicies": true,
    "@aws-cdk/core:validateSnapshotRemovalPolicy": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeyAliasStackSafeResourceName": true,
    "@aws-cdk/aws-s3:createDefaultLoggingPolicy": true,
    "@aws-cdk/aws-sns-subscriptions:restrictSqsDescryption": true,
    "@aws-cdk/aws-apigateway:disableCloudWatchRole": true,
    "@aws-cdk/core:enablePartitionLiterals": true,
    "@aws-cdk/aws-events:eventsTargetQueueSameAccount": true,
    "@aws-cdk/aws-ecs:disableExplicitDeploymentControllerForCircuitBreaker": true,
    "@aws-cdk/aws-iam:importedRoleStackSafeDefaultPolicyName": true,
    "@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy": true,
    "@aws-cdk/aws-route53-patters:useCertificate": true,
    "@aws-cdk/customresources:installLatestAwsSdkDefault": false,
    "@aws-cdk/aws-rds:databaseProxyUniqueResourceName": true,
    "@aws-cdk/aws-codedeploy:removeAlarmsFromDeploymentGroup": true,
    "@aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId": true,
    "@aws-cdk/aws-ec2:launchTemplateDefaultUserData": true,
    "@aws-cdk/aws-secretsmanager:useAttachedSecretResourcePolicyForSecretTargetAttachments": true,
    "@aws-cdk/aws-redshift:columnId": true,
    "@aws-cdk/aws-stepfunctions-tasks:enableEmrServicePolicyV2": true,
    "@aws-cdk/aws-ec2:restrictDefaultSecurityGroup": true,
    "@aws-cdk/aws-apigateway:requestValidatorUniqueId": true,
    "@aws-cdk/aws-kms:aliasNameRef": true,
    "@aws-cdk/aws-autoscaling:generateLaunchTemplateInsteadOfLaunchConfig": true,
    "@aws-cdk/core:includePrefixInUniqueNameGeneration": true,
    "@aws-cdk/aws-efs:denyAnonymousAccess": true,
    "@aws-cdk/aws-opensearchservice:enableOpensearchMultiAzWithStandby": true,
    "@aws-cdk/aws-lambda-nodejs:useLatestRuntimeVersion": true,
    "@aws-cdk/aws-efs:mountTargetOrderInsensitiveLogicalId": true,
    "@aws-cdk/aws-rds:auroraClusterChangeScopeOfInstanceParameterGroupWithEachParameters": true,
    "@aws-cdk/aws-appsync:useArnForSourceApiAssociationIdentifier": true,
    "@aws-cdk/aws-rds:preventRenderingDeprecatedCredentials": true,
    "@aws-cdk/aws-codepipeline-actions:useNewDefaultBranchForCodeCommitSource": true,
    "@aws-cdk/aws-cloudwatch-actions:changeLambdaPermissionLogicalIdForLambdaAction": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeysDefaultValueToFalse": true,
    "@aws-cdk/aws-codepipeline:defaultPipelineTypeToV2": true,
    "@aws-cdk/aws-kms:reduceCrossAccountRegionPolicyScope": true,
    "@aws-cdk/aws-eks:nodegroupNameAttribute": true,
    "@aws-cdk/aws-ec2:ebsDefaultGp3Volume": true,
    "@aws-cdk/aws-ecs:removeDefaultDeploymentAlarm": true,
    "@aws-cdk/custom-resources:logApiResponseDataPropertyTrueDefault": false,
    "@aws-cdk/aws-s3:keepNotificationInImportedBucket": false,
    "@aws-cdk/aws-ecs:enableImdsBlockingDeprecatedFeature": false,
    "@aws-cdk/aws-ecs:disableEcsImdsBlocking": true,
    "@aws-cdk/aws-ecs:reduceEc2FargateCloudWatchPermissions": true,
    "@aws-cdk/aws-dynamodb:resourcePolicyPerReplica": true,
    "@aws-cdk/aws-ec2:ec2SumTImeoutEnabled": true,
    "@aws-cdk/aws-appsync:appSyncGraphQLAPIScopeLambdaPermission": true,
    "@aws-cdk/aws-rds:setCorrectValueForDatabaseInstanceReadReplicaInstanceResourceId": true,
    "@aws-cdk/core:cfnIncludeRejectComplexResourceUpdateCreatePolicyIntrinsics": true,
    "@aws-cdk/aws-lambda-nodejs:sdkV3ExcludeSmithyPackages": true,
    "@aws-cdk/aws-stepfunctions-tasks:fixRunEcsTaskPolicy": true,
    "@aws-cdk/aws-ec2:bastionHostUseAmazonLinux2023ByDefault": true,
    "@aws-cdk/aws-route53-targets:userPoolDomainNameMethodWithoutCustomResource": true,
    "@aws-cdk/aws-elasticloadbalancingV2:albDualstackWithoutPublicIpv4SecurityGroupRulesDefault": true,
    "@aws-cdk/aws-iam:oidcRejectUnauthorizedConnections": true,
    "@aws-cdk/core:enableAdditionalMetadataCollection": true
  }
}

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/curl-scripts/auth/functions.sh
#!/bin/bash
# Cargar la URL base desde un script externo
source curl-scripts/set-API-URL.sh
# Verificar que API_URL est√° disponible
if [ -z "$API_URL" ]; then
    echo "‚ùå Error: API_URL no est√° configurado. Revisa set-API-URL.sh"
    exit 1
fi
# Variables globales para almacenar resultados
USER_EMAIL=""
USER_PASSWORD="Test1234!"
USER_NAME=""
TOKEN=""
# Funci√≥n para generar un email aleatorio
generate_random_email() {
  USER_EMAIL="user$RANDOM@example.com"
}
# Funci√≥n para generar un nombre de usuario aleatorio
generate_random_username() {
  USER_NAME="user$RANDOM"
}
# Funci√≥n para registrar un usuario
sign_up() {
  generate_random_username
  generate_random_email
  local telegram="@${USER_NAME}"
  local telefono="123456789"
  echo "üîπ Registrando usuario: $USER_NAME ($USER_EMAIL)"
  local response=$(curl -s -X POST "$API_URL/auth/sign-up" \
    -H "Content-Type: application/json" \
    -d "{
          \"username\": \"$USER_NAME\",
          \"email\": \"$USER_EMAIL\",
          \"password\": \"$USER_PASSWORD\",
          \"telegram\": \"$telegram\",
          \"telefono\": \"$telefono\"
        }")
  echo "üìå Respuesta de sign-up:"
  echo "$response"
}
# Funci√≥n para iniciar sesi√≥n
log_in() {
  echo "üîπ Iniciando sesi√≥n con: $USER_EMAIL"
  local response=$(curl -s -X POST "$API_URL/auth/log-in" \
    -H "Content-Type: application/json" \
    -d "{
          \"email\": \"$USER_EMAIL\",
          \"password\": \"$USER_PASSWORD\"
        }")
  TOKEN=$(echo "$response" | grep -o '"token":"[^"]*' | cut -d':' -f2 | tr -d '"')
  echo "üìå Respuesta de log-in:"
  echo "$response"
  if [ -n "$TOKEN" ]; then
    echo "üîë Token obtenido: $TOKEN"
  else
    echo "‚ùå Error al obtener el token."
    exit 1
  fi
}
# Funci√≥n para cerrar sesi√≥n
log_out() {
  if [ -z "$TOKEN" ]; then
    echo "‚ùå No se encontr√≥ un token activo. Inicia sesi√≥n primero."
    exit 1
  fi
  echo "üîπ Cerrando sesi√≥n..."
  local response=$(curl -s -X POST "$API_URL/auth/log-out" \
    -H "Authorization: Bearer $TOKEN")
  echo "üìå Respuesta de log-out:"
  echo "$response"
  # Limpiar variables
  TOKEN=""
  USER_EMAIL=""
  USER_NAME=""
}
# Ejecutar todas las funciones autom√°ticamente
sign_up
log_in
log_out

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/curl-scripts/set-API-URL.sh
#!/bin/bash
API_URL="https:
echo "API_URL set to $API_URL"

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/curl-scripts/test-apis.sh
#!/bin/bash
# Definir la URL base de la API
source curl-scripts/set-API-URL.sh
# Funci√≥n para probar conductores
test_conductores() {
    echo -e "\nProbando POST /conductores"
    CONDUCTOR_RESPONSE=$(curl -s -X POST "$API_URL/conductores" \
        -H "Content-Type: application/json" \
        -d '{
            "Usuario_ID": "12345",
            "Foto_DNI": "url_foto_dni",
            "Foto_VTV": "url_foto_vtv",
            "Estado": "Pendiente"
        }')
    echo "Respuesta: $CONDUCTOR_RESPONSE"
    # Extraer ID del conductor
    CONDUCTOR_ID=$(echo "$CONDUCTOR_RESPONSE" | jq -r '.id')
    echo ""
    echo -e "\nProbando GET /conductores/$CONDUCTOR_ID"
    curl -s -X GET "$API_URL/conductores/$CONDUCTOR_ID"
    echo ""
    echo "ID del conductor creado: $CONDUCTOR_ID"
    echo ""
    echo -e "\nProbando GET /conductores"
    curl -s -X GET "$API_URL/conductores"
    echo ""
    echo -e "\nProbando PUT /conductores/$CONDUCTOR_ID"
    curl -s -X PUT "$API_URL/conductores/$CONDUCTOR_ID" \
        -H "Content-Type: application/json" \
        -d '{
            "Estado": "Aprobado"
        }'
    echo ""
    echo -e "\nProbando DELETE /conductores/$CONDUCTOR_ID"
    curl -s -X DELETE "$API_URL/conductores/$CONDUCTOR_ID"
}
# Funci√≥n para probar rutas
test_rutas() {
    echo -e "\nProbando POST /rutas"
    RUTA_RESPONSE=$(curl -s -X POST "$API_URL/rutas" \
        -H "Content-Type: application/json" \
        -d '{
            "conductorId": "12345",
            "estado": "activa",
            "paradasDeRuta": [
                {
                    "id": "",
                    "parada": {
                        "id": "",
                        "nombre": "Parada 1",
                        "direccion": "Av. Primera 123",
                        "descripcion": "Parada inicial"
                    },
                    "posicion": 1,
                    "horario": "08:00"
                },
                {
                    "id": "",
                    "parada": {
                        "id": "",
                        "nombre": "Parada 2",
                        "direccion": "Av. Segunda 456",
                        "descripcion": "Parada intermedia"
                    },
                    "posicion": 2,
                    "horario": "10:00"
                }
            ]
        }')
    echo "Respuesta: $RUTA_RESPONSE"
    echo ""
    # Extraer ID de la ruta
    RUTA_ID=$(echo "$RUTA_RESPONSE" | jq -r '.id')
    echo "ID de la ruta creada: $RUTA_ID"
    echo ""
    echo -e "\nProbando GET /rutas"
    curl -s -X GET "$API_URL/rutas"
    echo ""
    echo -e "\nProbando GET /rutas/$RUTA_ID"
    curl -s -X GET "$API_URL/rutas/$RUTA_ID"
    echo ""
    echo -e "\nProbando PUT /rutas/$RUTA_ID"
    curl -s -X PUT "$API_URL/rutas/$RUTA_ID" \
        -H "Content-Type: application/json" \
        -d '{
            "estado": "inactiva"
        }'
    echo ""
    echo -e "\nProbando DELETE /rutas/$RUTA_ID"
    curl -s -X DELETE "$API_URL/rutas/$RUTA_ID"
    echo ""
}
# Funci√≥n para probar paradas
test_paradas() {
    echo -e "\nProbando POST /paradas"
    PARADA_RESPONSE=$(curl -s -X POST "$API_URL/paradas" \
        -H "Content-Type: application/json" \
        -d '{
            "id": "parada-123",
            "nombre": "Parada Central",
            "descripcion": "Parada principal en el centro",
            "calle": "Av. Siempre Viva",
            "numero": "742",
            "localidad": "Springfield",
            "codigoPostal": "12345",
            "partido": "Capital",
            "provincia": "Buenos Aires",
            "latitud": -34.603722,
            "longitud": -58.381592
        }')
    echo "Respuesta: $PARADA_RESPONSE"
    # Extraer ID de la parada
    PARADA_ID=$(echo "$PARADA_RESPONSE" | jq -r '.id')
    echo -e "\nProbando GET /paradas/$PARADA_ID"
    curl -s -X GET "$API_URL/paradas/$PARADA_ID"
    echo ""
    echo -e "\nProbando GET /paradas"
    curl -s -X GET "$API_URL/paradas"
    echo ""
    echo -e "\nProbando PUT /paradas/$PARADA_ID"
    curl -s -X PUT "$API_URL/paradas/$PARADA_ID" \
        -H "Content-Type: application/json" \
        -d '{
            "nombre": "Parada Central Actualizada",
            "descripcion": "Parada principal actualizada",
            "calle": "Av. Siempre Viva",
            "numero": "742",
            "localidad": "Springfield",
            "codigoPostal": "12345",
            "partido": "Capital",
            "provincia": "Buenos Aires",
            "latitud": -34.603722,
            "longitud": -58.381592
        }'
    echo ""
    echo -e "\nProbando DELETE /paradas/$PARADA_ID"
    curl -s -X DELETE "$API_URL/paradas/$PARADA_ID"
    echo ""
}
test_paradas_de_ruta() {
    echo -e "\nProbando POST /paradasDeRuta"
    PARADA_RESPONSE=$(curl -s -X POST "$API_URL/paradasDeRuta" \
        -H "Content-Type: application/json" \
        -d '{
            "parada": {
                "id": "",
                "nombre": "Parada Central",
                "direccion": "Av. Siempre Viva 742",
                "descripcion": "Parada principal en el centro"
            },
            "posicion": 1,
            "horario": "07:30"
        }')
    echo "Respuesta: $PARADA_RESPONSE"
    echo ""
    # Extraer ID de la parada de ruta
    PARADA_ID=$(echo "$PARADA_RESPONSE" | jq -r '.id')
    echo "ID de la parada creada: $PARADA_ID"
    echo ""
    echo -e "\nProbando GET /paradasDeRuta"
    curl -s -X GET "$API_URL/paradasDeRuta"
    echo ""
    echo -e "\nProbando GET /paradasDeRuta/$PARADA_ID"
    curl -s -X GET "$API_URL/paradasDeRuta/$PARADA_ID"
    echo ""
    echo -e "\nProbando PUT /paradasDeRuta/$PARADA_ID"
    curl -s -X PUT "$API_URL/paradasDeRuta/$PARADA_ID" \
        -H "Content-Type: application/json" \
        -d '{
            "horario": "08:15"
        }'
    echo ""
    echo -e "\nProbando DELETE /paradasDeRuta/$PARADA_ID"
    curl -s -X DELETE "$API_URL/paradasDeRuta/$PARADA_ID"
    echo ""
}
# Funci√≥n para agregar una parada a una ruta
agregar_parada_a_ruta() {
    echo -e "\nProbando agregar parada a ruta"
    curl -s -X PUT "$API_URL/rutas/$RUTA_ID" \
        -H "Content-Type: application/json" \
        -d '{
            "paradasDeRuta": [
                {
                    "id": "",
                    "parada": {
                        "id": "",
                        "nombre": "Nueva Parada",
                        "direccion": "Calle 123",
                        "descripcion": "Descripci√≥n opcional"
                    },
                    "posicion": 3,
                    "horario": "08:30"
                }
            ]
        }'
    echo ""
}
# Funci√≥n para eliminar una parada de una ruta
eliminar_parada_de_ruta() {
    echo -e "\nProbando eliminar parada de ruta"
    curl -s -X PUT "$API_URL/rutas/$RUTA_ID" \
        -H "Content-Type: application/json" \
        -d '{
            "paradasDeRuta": [
                {
                    "id": "id-de-la-parada-a-eliminar"
                }
            ]
        }'
    echo ""
}
# Funci√≥n para probar viajes
test_viajes() {
    echo -e "\nProbando POST /viajes"
    VIAJE_RESPONSE=$(curl -s -X POST "$API_URL/viajes" \
        -H "Content-Type: application/json" \
        -d '{
            "conductorId": "12345",
            "rutaId": "67890",
            "estado": "programado",
            "fechaHoraSalida": "2025-02-25T08:00:00Z",
            "fechaHoraLlegada": "2025-02-25T10:00:00Z",
            "capacidad": 20,
            "pasajeros": []
        }')
    echo "Respuesta: $VIAJE_RESPONSE"
    # Extraer ID del viaje
    VIAJE_ID=$(echo "$VIAJE_RESPONSE" | jq -r '.id')
    echo ""
    echo -e "\nProbando GET /viajes/$VIAJE_ID"
    curl -s -X GET "$API_URL/viajes/$VIAJE_ID"
    echo ""
    echo "ID del viaje creado: $VIAJE_ID"
    echo ""
    echo -e "\nProbando GET /viajes"
    curl -s -X GET "$API_URL/viajes"
    echo ""
    echo -e "\nProbando PUT /viajes/$VIAJE_ID"
    curl -s -X PUT "$API_URL/viajes/$VIAJE_ID" \
        -H "Content-Type: application/json" \
        -d '{
            "estado": "en curso"
        }'
    echo ""
    echo -e "\nProbando DELETE /viajes/$VIAJE_ID"
    curl -s -X DELETE "$API_URL/viajes/$VIAJE_ID"
    echo ""
}
# # Verificar que jq est√° instalado
if ! command -v jq &> /dev/null
then
    echo "Error: jq no est√° instalado. Inst√°lalo con 'sudo apt install jq' (Linux) o 'brew install jq' (Mac)."
    exit 1
fi
# Ejecutar todas las pruebas
# test_paradas
# test_rutas
test_paradas_de_ruta
# test_conductores
# agregar_parada_a_ruta
# eliminar_parada_de_ruta
# test_viajes

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/curl-scripts/usuarios/crud.sh
# #!/bin/bash
# Configuraci√≥n base (ajustar seg√∫n entorno)
# Cargar la URL base desde un script externo
source curl-scripts/set-API-URL.sh
USER_EMAIL="juan@example.com"
USER_PASSWORD="secreto123"
sign_up() {
  local telegram="@${USER_NAME}"
  local telefono="123456789"
  echo "üîπ Registrando usuario: $USER_NAME ($USER_EMAIL)"
  local response=$(curl -s -X POST "$API_URL/auth/sign-up" \
    -H "Content-Type: application/json" \
    -d "{
          \"username\": \"$USER_NAME\",
          \"email\": \"$USER_EMAIL\",
          \"password\": \"$USER_PASSWORD\",
          \"telegram\": \"$telegram\",
          \"telefono\": \"$telefono\"
        }")
  echo "üìå Respuesta de sign-up:"
  echo "$response"
}
# Funci√≥n para iniciar sesi√≥n y obtener el JWT
login() {
  echo "üîπ Iniciando sesi√≥n para obtener JWT..."
  LOGIN_RESPONSE=$(curl -s -X POST "$API_URL/auth/log-in" \
    -H "Content-Type: application/json" \
    -d "{
         \"email\": \"$USER_EMAIL\",
         \"password\": \"$USER_PASSWORD\"
        }")
  TOKEN=$(echo "$LOGIN_RESPONSE" | grep -o '"token":"[^"]*' | cut -d':' -f2 | tr -d '"')
  if [ -z "$TOKEN" ]; then
    echo "‚ùå Error: No se obtuvo el token de login"
    exit 1
  else
    echo "üîë Token obtenido: $TOKEN"
  fi
}
# Endpoint base para usuarios
USUARIOS_ENDPOINT="${API_URL}/usuarios"
# Funci√≥n para crear un usuario
crear_usuario() {
  echo "Creando usuario..."
  local response=$(curl -s -X POST -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -d '{
      "credentials": {
        "username": "juan_perez",
        "email": "juan@example.com",
        "password": "secreto123",
        "telegram": "@juanp",
        "telefono": "+5491112345678"
      },
      "rol": "Conductor",
      "estado": "Pendiente"
    }' \
    ${USUARIOS_ENDPOINT})
  echo "Respuesta creaci√≥n:"
  echo "$response" | jq .
  # Extraer ID del usuario creado
  local user_id=$(echo "$response" | jq -r '.id')
  echo "ID Usuario creado: $user_id"
  echo "$user_id"
}
# Funci√≥n para obtener todos los usuarios
listar_usuarios() {
  echo -e "\nListando todos los usuarios..."
  curl -s -X GET -H "Authorization: Bearer $TOKEN" ${USUARIOS_ENDPOINT} | jq .
}
# Funci√≥n para obtener un usuario por ID
obtener_usuario() {
  local user_id=$1
  echo -e "\nObteniendo usuario $user_id..."
  curl -s -X GET -H "Authorization: Bearer $TOKEN" ${USUARIOS_ENDPOINT}/${user_id} | jq .
}
# Funci√≥n para actualizar un usuario
actualizar_usuario() {
  local user_id=$1
  echo -e "\nActualizando usuario $user_id..."
  curl -s -X PUT -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN" \
    -d '{
      "estado": "Aprobado",
      "credentials": {
        "telefono": "+5491122334455"
      }
    }' \
    ${USUARIOS_ENDPOINT}/${user_id} | jq .
}
# Funci√≥n para eliminar un usuario
eliminar_usuario() {
  local user_id=$1
  echo -e "\nEliminando usuario $user_id..."
  curl -s -X DELETE -H "Authorization: Bearer $TOKEN" ${USUARIOS_ENDPOINT}/${user_id}
}
# Funci√≥n para verificar si un usuario fue eliminado
verificar_eliminacion() {
  local user_id=$1
  echo -e "\nVerificando eliminaci√≥n..."
  curl -s -X GET -H "Authorization: Bearer $TOKEN" ${USUARIOS_ENDPOINT}/${user_id} | jq .
}
# Ejecutar el flujo completo
sign_up
login
USER_ID=$(crear_usuario)
listar_usuarios
obtener_usuario "$USER_ID"
actualizar_usuario "$USER_ID"
eliminar_usuario "$USER_ID"
verificar_eliminacion "$USER_ID"

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/bin/minibus-backend-aws-cdk.ts
#!/usr/bin/env node
import * as cdk from "aws-cdk-lib";
import { MinibusBackendAwsCdkStack } from "../lib/minibus-backend-aws-cdk-stack";
import "dotenv/config";
const app = new cdk.App();
new MinibusBackendAwsCdkStack(app, "MinibusBackendAwsCdkStack", {
  /* For more information, see https:
});

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/handlers/auth.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { createUser, listUsers } from "../models/userModel";
const bcrypt = require("bcryptjs");
import * as jwt from "jsonwebtoken";
const USERS_TABLE = process.env.USERS_TABLE || "Users";
const JWT_SECRET = process.env.JWT_SECRET || "your_jwt_secret";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const path = event.path.toLowerCase();
  if (event.httpMethod !== "POST") {
    return {
      statusCode: 405,
      body: JSON.stringify({ message: "M√©todo no permitido" }),
    };
  }
  try {
    if (path.endsWith("sign-up")) {
      if (!event.body) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "Cuerpo de solicitud faltante" }),
        };
      }
      const data = JSON.parse(event.body);
      const { username, email, password, telegram, telefono } = data;
      if (!username || !email || !password) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "Faltan campos obligatorios" }),
        };
      }
      const users = await listUsers();
      const existingUser = users.find(
        (u) =>
          u.credentials.email.toLowerCase() === email.toLowerCase() ||
          u.credentials.username.toLowerCase() === username.toLowerCase()
      );
      if (existingUser) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "El usuario ya existe" }),
        };
      }
      const hashedPassword = await bcrypt.hash(password, 10);
      const newUser = await createUser({
        credentials: {
          username,
          email,
          password: "", 
          hashedPassword,
          telegram: telegram || "",
          telefono: telefono || "",
        },
        rol: "Conductor", 
        estado: "Pendiente",
        fechaCreacion: new Date().toISOString(),
      });
      return {
        statusCode: 201,
        body: JSON.stringify({
          message: "Usuario creado exitosamente",
          user: newUser,
        }),
      };
    } else if (path.endsWith("log-in")) {
      if (!event.body) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "Cuerpo de solicitud faltante" }),
        };
      }
      const data = JSON.parse(event.body);
      const { email, password } = data;
      if (!email || !password) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "Faltan campos obligatorios" }),
        };
      }
      const users = await listUsers();
      const user = users.find(
        (u) => u.credentials.email.toLowerCase() === email.toLowerCase()
      );
      if (!user) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "Credenciales inv√°lidas" }),
        };
      }
      const validPassword = await bcrypt.compare(
        password,
        user.credentials.hashedPassword
      );
      if (!validPassword) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "Credenciales inv√°lidas" }),
        };
      }
      const token = jwt.sign(
        { id: user.id, email: user.credentials.email, rol: user.rol },
        JWT_SECRET,
        { expiresIn: "1h" }
      );
      return {
        statusCode: 200,
        body: JSON.stringify({ message: "Log in exitoso", token }),
      };
    } else if (path.endsWith("log-out")) {
      return {
        statusCode: 200,
        body: JSON.stringify({ message: "Log out exitoso" }),
      };
    } else {
      return {
        statusCode: 404,
        body: JSON.stringify({ message: "Ruta no encontrada" }),
      };
    }
  } catch (error: any) {
    console.error("Error en auth handler:", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno", error: error.message }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/handlers/conductores.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import {
  createConductor,
  getConductor,
  updateConductor,
  deleteConductor,
  listConductores,
} from "../models/conductorModel";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const { httpMethod, pathParameters, body } = event;
  try {
    switch (httpMethod) {
      case "GET":
        if (pathParameters?.id) {
          const conductor = await getConductor(pathParameters.id);
          if (!conductor) {
            return {
              statusCode: 404,
              body: JSON.stringify({ message: "Conductor no encontrado" }),
            };
          }
          return { statusCode: 200, body: JSON.stringify(conductor) };
        } else {
          const conductores = await listConductores();
          return { statusCode: 200, body: JSON.stringify(conductores) };
        }
      case "POST":
        if (!body) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "Falta el cuerpo de la solicitud",
            }),
          };
        }
        const data = JSON.parse(body);
        if (!data.Usuario_ID) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Usuario_ID es obligatorio" }),
          };
        }
        const newConductor = await createConductor(data);
        return { statusCode: 201, body: JSON.stringify(newConductor) };
      case "PUT":
        if (!pathParameters?.id || !body) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "Falta el ID o el cuerpo de la solicitud",
            }),
          };
        }
        const updateData = JSON.parse(body);
        const updatedConductor = await updateConductor(
          pathParameters.id,
          updateData
        );
        return { statusCode: 200, body: JSON.stringify(updatedConductor) };
      case "DELETE":
        if (!pathParameters?.id) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Falta el ID en la ruta" }),
          };
        }
        await deleteConductor(pathParameters.id);
        return { statusCode: 204, body: "" };
      default:
        return {
          statusCode: 405,
          body: JSON.stringify({ message: "M√©todo no permitido" }),
        };
    }
  } catch (error: any) {
    console.error("Error:", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno", error: error.message }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/handlers/usuarios.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import * as jwt from "jsonwebtoken";
import {
  createUser,
  getUser,
  updateUser,
  deleteUser,
  listUsers,
} from "../models/userModel";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const { httpMethod, pathParameters, body } = event;
  const authHeader = event.headers.Authorization || event.headers.authorization;
  if (!authHeader) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: falta el token" }),
    };
  }
  const token = authHeader.split(" ")[1]; 
  if (!token) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token mal formado" }),
    };
  }
  try {
    jwt.verify(token, process.env.JWT_SECRET || "your_jwt_secret");
  } catch (err) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token inv√°lido" }),
    };
  }
  try {
    switch (httpMethod) {
      case "GET":
        if (pathParameters?.id) {
          const user = await getUser(pathParameters.id);
          return user
            ? { statusCode: 200, body: JSON.stringify(user) }
            : {
                statusCode: 404,
                body: JSON.stringify({ message: "Usuario no encontrado" }),
              };
        } else {
          const users = await listUsers();
          return { statusCode: 200, body: JSON.stringify(users) };
        }
      case "POST":
        if (!body) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Cuerpo de solicitud faltante" }),
          };
        }
        const newUser = await createUser(JSON.parse(body));
        return { statusCode: 201, body: JSON.stringify(newUser) };
      case "PUT":
        if (!pathParameters?.id || !body) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Falta ID o cuerpo de solicitud" }),
          };
        }
        const updatedUser = await updateUser(
          pathParameters.id,
          JSON.parse(body)
        );
        return { statusCode: 200, body: JSON.stringify(updatedUser) };
      case "DELETE":
        if (!pathParameters?.id) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Falta ID en la ruta" }),
          };
        }
        await deleteUser(pathParameters.id);
        return { statusCode: 204, body: "" };
      default:
        return {
          statusCode: 405,
          body: JSON.stringify({ message: "M√©todo no permitido" }),
        };
    }
  } catch (error: any) {
    console.error("Error:", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno", error: error.message }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/lib/dynamodb-construct.ts
import * as cdk from "aws-cdk-lib";
import { Construct } from "constructs";
import * as dynamodb from "aws-cdk-lib/aws-dynamodb";
export class DynamoDBConstruct extends Construct {
  public readonly usersTable: dynamodb.Table;
  public readonly driversTable: dynamodb.Table;
  public readonly vendorsTable: dynamodb.Table;
  public readonly routesTable: dynamodb.Table;
  public readonly commissionsTable: dynamodb.Table;
  public readonly paradasTable: dynamodb.Table; 
  public readonly paradasDeRutaTable: dynamodb.Table; 
  public readonly viajesTable: dynamodb.Table; 
  constructor(scope: Construct, id: string) {
    super(scope, id);
    this.usersTable = new dynamodb.Table(this, "UsersTable", {
      tableName: "Users",
      partitionKey: { name: "id", type: dynamodb.AttributeType.STRING },
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
    });
    this.usersTable.addGlobalSecondaryIndex({
      indexName: "UsersByRoleIndex",
      partitionKey: { name: "role", type: dynamodb.AttributeType.STRING },
    });
    this.driversTable = new dynamodb.Table(this, "DriversTable", {
      tableName: "Drivers",
      partitionKey: { name: "id", type: dynamodb.AttributeType.STRING },
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
    });
    this.driversTable.addGlobalSecondaryIndex({
      indexName: "DriverByUserIndex",
      partitionKey: { name: "usuarioId", type: dynamodb.AttributeType.STRING },
    });
    this.driversTable.addGlobalSecondaryIndex({
      indexName: "DriversByVendorIndex",
      partitionKey: { name: "vendedorId", type: dynamodb.AttributeType.STRING },
    });
    this.routesTable = new dynamodb.Table(this, "RoutesTable", {
      tableName: "Routes",
      partitionKey: { name: "id", type: dynamodb.AttributeType.STRING },
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
    });
    this.routesTable.addGlobalSecondaryIndex({
      indexName: "RoutesByConductorIndex",
      partitionKey: {
        name: "conductorId",
        type: dynamodb.AttributeType.STRING,
      },
    });
    this.paradasTable = new dynamodb.Table(this, "ParadasTable", {
      tableName: "Paradas",
      partitionKey: { name: "id", type: dynamodb.AttributeType.STRING },
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
    });
    this.paradasTable.addGlobalSecondaryIndex({
      indexName: "ParadasByRutaIndex",
      partitionKey: { name: "direccion", type: dynamodb.AttributeType.STRING },
    });
    this.paradasDeRutaTable = new dynamodb.Table(this, "ParadasDeRutaTable", {
      tableName: "ParadasDeRuta",
      partitionKey: { name: "id", type: dynamodb.AttributeType.STRING },
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
    });
    this.paradasDeRutaTable.addGlobalSecondaryIndex({
      indexName: "ParadasPorLocalidadIndex",
      partitionKey: { name: "localidad", type: dynamodb.AttributeType.STRING },
      sortKey: { name: "provincia", type: dynamodb.AttributeType.STRING },
      projectionType: dynamodb.ProjectionType.ALL, 
    });
    this.viajesTable = new dynamodb.Table(this, "ViajesTable", {
      tableName: "Viajes",
      partitionKey: { name: "id", type: dynamodb.AttributeType.STRING },
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
    });
    this.viajesTable.addGlobalSecondaryIndex({
      indexName: "ViajesByParadasIndex",
      partitionKey: { name: "paradaId", type: dynamodb.AttributeType.STRING },
      sortKey: { name: "createdAt", type: dynamodb.AttributeType.STRING },
      projectionType: dynamodb.ProjectionType.INCLUDE,
      nonKeyAttributes: ["rutaId", "conductorId", "estado"],
    });
    this.viajesTable.addGlobalSecondaryIndex({
      indexName: "ViajesPorRutaIndex",
      partitionKey: { name: "rutaId", type: dynamodb.AttributeType.STRING },
      sortKey: { name: "createdAt", type: dynamodb.AttributeType.STRING },
      projectionType: dynamodb.ProjectionType.ALL,
    });
    this.viajesTable.addGlobalSecondaryIndex({
      indexName: "ViajesPorConductorIndex",
      partitionKey: {
        name: "conductorId",
        type: dynamodb.AttributeType.STRING,
      },
      sortKey: { name: "createdAt", type: dynamodb.AttributeType.STRING },
      projectionType: dynamodb.ProjectionType.ALL,
    });
  }
}

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/lib/handlers-construct.ts
import * as cdk from "aws-cdk-lib";
import { Construct } from "constructs";
import * as lambda from "aws-cdk-lib/aws-lambda";
import * as lambdaNode from "aws-cdk-lib/aws-lambda-nodejs";
import * as path from "path";
import * as dynamodb from "aws-cdk-lib/aws-dynamodb";
interface HandlersConstructProps {
  driversTable: dynamodb.Table;
  routesTable: dynamodb.Table;
  paradasTable: dynamodb.Table;
  paradasDeRutaTable: dynamodb.Table;
  viajesTable: dynamodb.Table;
  usersTable: dynamodb.Table;
}
export class HandlersConstruct extends Construct {
  public readonly conductoresHandler: lambdaNode.NodejsFunction;
  public readonly rutasHandler: lambdaNode.NodejsFunction;
  public readonly paradasHandler: lambdaNode.NodejsFunction;
  public readonly paradasDeRutaHandler: lambdaNode.NodejsFunction;
  public readonly viajesHandler: lambdaNode.NodejsFunction;
  public readonly usuariosHandler: lambdaNode.NodejsFunction;
  public readonly authHandler: lambdaNode.NodejsFunction;
  constructor(scope: Construct, id: string, props: HandlersConstructProps) {
    super(scope, id);
    this.conductoresHandler = new lambdaNode.NodejsFunction(
      this,
      "ConductoresHandler",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../handlers/conductores.ts"),
        handler: "handler",
        environment: {
          USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
          CONDUCTORES_TABLE: props.driversTable.tableName,
        },
        bundling: { externalModules: ["@aws-sdk"] },
      }
    );
    this.rutasHandler = new lambdaNode.NodejsFunction(this, "RutasHandler", {
      runtime: lambda.Runtime.NODEJS_18_X,
      entry: path.join(__dirname, "../handlers/rutas.ts"),
      handler: "handler",
      environment: {
        USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
        RUTAS_TABLE: props.routesTable.tableName,
      },
      bundling: { externalModules: ["@aws-sdk"] },
    });
    this.paradasHandler = new lambdaNode.NodejsFunction(
      this,
      "ParadasHandler",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../handlers/paradas.ts"),
        handler: "handler",
        environment: {
          USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
          PARADAS_TABLE: props.paradasTable.tableName,
        },
        bundling: { externalModules: ["@aws-sdk"] },
      }
    );
    this.paradasDeRutaHandler = new lambdaNode.NodejsFunction(
      this,
      "ParadasDeRutaHandler",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../handlers/paradasDeRuta.ts"),
        handler: "handler",
        environment: {
          USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
          PARADAS_TABLE: props.paradasDeRutaTable.tableName,
        },
        bundling: { externalModules: ["@aws-sdk"] },
      }
    );
    this.viajesHandler = new lambdaNode.NodejsFunction(this, "ViajesHandler", {
      runtime: lambda.Runtime.NODEJS_18_X,
      entry: path.join(__dirname, "../handlers/viajes.ts"),
      handler: "handler",
      environment: {
        USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
        TRIPS_TABLE: props.viajesTable.tableName,
        PARADAS_DE_RUTA_TABLE: props.paradasDeRutaTable.tableName, 
      },
      bundling: { externalModules: ["@aws-sdk"] },
    });
    this.usuariosHandler = new lambdaNode.NodejsFunction(
      this,
      "UsuariosHandler",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../handlers/usuarios.ts"),
        handler: "handler",
        environment: {
          USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
          USERS_TABLE: props.usersTable.tableName,
        },
        bundling: { externalModules: ["@aws-sdk"] },
      }
    );
    this.authHandler = new lambdaNode.NodejsFunction(this, "AuthHandler", {
      runtime: lambda.Runtime.NODEJS_18_X,
      entry: path.join(__dirname, "../handlers/auth.ts"),
      handler: "handler",
      environment: {
        USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
        USERS_TABLE: props.usersTable.tableName,
        JWT_SECRET: process.env.JWT_SECRET || "your_jwt_secret",
      },
      bundling: { externalModules: ["@aws-sdk"] },
    });
    props.usersTable.grantReadWriteData(this.usuariosHandler);
    props.viajesTable.grantReadWriteData(this.viajesHandler);
    props.driversTable.grantReadWriteData(this.conductoresHandler);
    props.routesTable.grantReadWriteData(this.rutasHandler);
    props.paradasTable.grantReadWriteData(this.paradasHandler);
    props.paradasDeRutaTable.grantReadWriteData(this.paradasDeRutaHandler);
  }
}

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/lib/minibus-backend-aws-cdk-stack.ts
import * as cdk from "aws-cdk-lib";
import { Construct } from "constructs";
import { DynamoDBConstruct } from "./dynamodb-construct";
import { HandlersConstruct } from "./handlers-construct";
import * as apigateway from "aws-cdk-lib/aws-apigateway";
export class MinibusBackendAwsCdkStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);
    console.log("LOCALSTACK:", process.env.USE_LOCALSTACK);
    const database = new DynamoDBConstruct(this, "Database");
    const handlers = new HandlersConstruct(this, "Handlers", {
      driversTable: database.driversTable,
      routesTable: database.routesTable,
      paradasTable: database.paradasTable,
      paradasDeRutaTable: database.paradasDeRutaTable,
      viajesTable: database.viajesTable,
      usersTable: database.usersTable,
    });
    const api = new apigateway.RestApi(this, "MinibusApi", {
      restApiName: "minibus-api",
      deployOptions: {
        stageName: process.env.USE_LOCALSTACK ? "dev" : "prod",
      },
      endpointConfiguration: {
        types: [apigateway.EndpointType.REGIONAL],
      },
    });
    const conductoresResource = api.root.addResource("conductores");
    conductoresResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(handlers.conductoresHandler)
    );
    conductoresResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(handlers.conductoresHandler)
    );
    const conductorResource = conductoresResource.addResource("{id}");
    conductorResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(handlers.conductoresHandler)
    );
    conductorResource.addMethod(
      "PUT",
      new apigateway.LambdaIntegration(handlers.conductoresHandler)
    );
    conductorResource.addMethod(
      "DELETE",
      new apigateway.LambdaIntegration(handlers.conductoresHandler)
    );
    new cdk.CfnOutput(this, "ApiUrl", {
      value: api.urlForPath("/conductores"),
      description: "Endpoint de conductores",
    });
    const rutasResource = api.root.addResource("rutas");
    rutasResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(handlers.rutasHandler)
    );
    rutasResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(handlers.rutasHandler)
    );
    const rutaResource = rutasResource.addResource("{id}");
    rutaResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(handlers.rutasHandler)
    );
    rutaResource.addMethod(
      "PUT",
      new apigateway.LambdaIntegration(handlers.rutasHandler)
    );
    rutaResource.addMethod(
      "DELETE",
      new apigateway.LambdaIntegration(handlers.rutasHandler)
    );
    const paradasResource = api.root.addResource("paradas");
    paradasResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(handlers.paradasHandler)
    );
    paradasResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(handlers.paradasHandler)
    );
    const paradaResource = paradasResource.addResource("{id}");
    paradaResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(handlers.paradasHandler)
    );
    paradaResource.addMethod(
      "PUT",
      new apigateway.LambdaIntegration(handlers.paradasHandler)
    );
    paradaResource.addMethod(
      "DELETE",
      new apigateway.LambdaIntegration(handlers.paradasHandler)
    );
    const paradasDeRutaResource = api.root.addResource("paradasDeRuta");
    paradasDeRutaResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(handlers.paradasDeRutaHandler)
    );
    paradasDeRutaResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(handlers.paradasDeRutaHandler)
    );
    const paradaDeRutaResource = paradasDeRutaResource.addResource("{id}");
    paradaDeRutaResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(handlers.paradasDeRutaHandler)
    );
    paradaDeRutaResource.addMethod(
      "PUT",
      new apigateway.LambdaIntegration(handlers.paradasDeRutaHandler)
    );
    paradaDeRutaResource.addMethod(
      "DELETE",
      new apigateway.LambdaIntegration(handlers.paradasDeRutaHandler)
    );
    const viajesResource = api.root.addResource("viajes");
    viajesResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(handlers.viajesHandler)
    );
    viajesResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(handlers.viajesHandler)
    );
    const viajeResource = viajesResource.addResource("{id}");
    viajeResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(handlers.viajesHandler)
    );
    viajeResource.addMethod(
      "PUT",
      new apigateway.LambdaIntegration(handlers.viajesHandler)
    );
    viajeResource.addMethod(
      "DELETE",
      new apigateway.LambdaIntegration(handlers.viajesHandler)
    );
    const usuariosResource = api.root.addResource("usuarios");
    usuariosResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(handlers.usuariosHandler)
    );
    usuariosResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(handlers.usuariosHandler)
    );
    const usuarioResource = usuariosResource.addResource("{id}");
    usuarioResource.addMethod(
      "GET",
      new apigateway.LambdaIntegration(handlers.usuariosHandler)
    );
    usuarioResource.addMethod(
      "PUT",
      new apigateway.LambdaIntegration(handlers.usuariosHandler)
    );
    usuarioResource.addMethod(
      "DELETE",
      new apigateway.LambdaIntegration(handlers.usuariosHandler)
    );
    const authResource = api.root.addResource("auth");
    const signUpResource = authResource.addResource("sign-up");
    signUpResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(handlers.authHandler)
    );
    const logInResource = authResource.addResource("log-in");
    logInResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(handlers.authHandler)
    );
    const logOutResource = authResource.addResource("log-out");
    logOutResource.addMethod(
      "POST",
      new apigateway.LambdaIntegration(handlers.authHandler)
    );
  }
}

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/models/conductorModel.ts
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocument } from "@aws-sdk/lib-dynamodb";
import {
  PutCommand,
  GetCommand,
  UpdateCommand,
  DeleteCommand,
  ScanCommand,
} from "@aws-sdk/lib-dynamodb";
import { v4 as uuidv4 } from "uuid";
import { Conductor } from "../types/conductor";
const isLocal = process.env.USE_LOCALSTACK === "true";
const dynamoEndpoint =
  process.env.DYNAMODB_ENDPOINT || "http:
const ddbClient = new DynamoDBClient({
  region: "us-east-1",
  ...(isLocal && {
    endpoint: dynamoEndpoint,
    credentials: {
      accessKeyId: "test",
      secretAccessKey: "test",
    },
  }),
});
const docClient = DynamoDBDocument.from(ddbClient, {
  marshallOptions: { removeUndefinedValues: true },
});
const TABLE_NAME = process.env.CONDUCTORES_TABLE || "Conductores";
export const createConductor = async (
  conductorData: Omit<Conductor, "id">
): Promise<Conductor> => {
  const newConductor: Conductor = {
    id: uuidv4(),
    ...conductorData,
  };
  await docClient.send(
    new PutCommand({
      TableName: TABLE_NAME,
      Item: newConductor,
    })
  );
  return newConductor;
};
export const getConductor = async (id: string): Promise<Conductor | null> => {
  const result = await docClient.send(
    new GetCommand({
      TableName: TABLE_NAME,
      Key: { id },
    })
  );
  return (result.Item as Conductor) || null;
};
export const updateConductor = async (
  id: string,
  updateData: Partial<Conductor>
): Promise<Conductor> => {
  const updateExpressions = Object.keys(updateData).map(
    (key) => `#${key} = :${key}`
  );
  const ExpressionAttributeNames = Object.keys(updateData).reduce(
    (acc, key) => ({ ...acc, [`#${key}`]: key }),
    {}
  );
  const ExpressionAttributeValues = Object.keys(updateData).reduce(
    (acc, key) => ({ ...acc, [`:${key}`]: updateData[key as keyof Conductor] }),
    {}
  );
  const { Attributes } = await docClient.send(
    new UpdateCommand({
      TableName: TABLE_NAME,
      Key: { id },
      UpdateExpression: `SET ${updateExpressions.join(", ")}`,
      ExpressionAttributeNames,
      ExpressionAttributeValues,
      ReturnValues: "ALL_NEW",
    })
  );
  return Attributes as Conductor;
};
export const deleteConductor = async (id: string): Promise<void> => {
  await docClient.send(
    new DeleteCommand({
      TableName: TABLE_NAME,
      Key: { id },
    })
  );
};
export const listConductores = async (): Promise<Conductor[]> => {
  const result = await docClient.send(
    new ScanCommand({
      TableName: TABLE_NAME,
    })
  );
  return result.Items as Conductor[];
};

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/models/userModel.ts
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocument } from "@aws-sdk/lib-dynamodb";
import {
  PutCommand,
  GetCommand,
  UpdateCommand,
  DeleteCommand,
  ScanCommand,
} from "@aws-sdk/lib-dynamodb";
import { v4 as uuidv4 } from "uuid";
import { User } from "../types/user";
const isLocal = process.env.USE_LOCALSTACK === "true";
const dynamoEndpoint = process.env.DYNAMODB_ENDPOINT;
const ddbClient = new DynamoDBClient({
  region: "us-east-1",
  ...(isLocal && {
    endpoint: dynamoEndpoint,
    credentials: {
      accessKeyId: "test",
      secretAccessKey: "test",
    },
  }),
});
const docClient = DynamoDBDocument.from(ddbClient, {
  marshallOptions: { removeUndefinedValues: true },
});
const TABLE_NAME = process.env.USERS_TABLE || "Users";
export const createUser = async (userData: Omit<User, "id">): Promise<User> => {
  const newUser: User = {
    id: uuidv4(),
    ...userData,
  };
  await docClient.send(
    new PutCommand({
      TableName: TABLE_NAME,
      Item: newUser,
    })
  );
  return newUser;
};
export const getUser = async (id: string): Promise<User | null> => {
  const result = await docClient.send(
    new GetCommand({
      TableName: TABLE_NAME,
      Key: { id },
    })
  );
  return (result.Item as User) || null;
};
export const updateUser = async (
  id: string,
  updateData: Partial<User>
): Promise<User> => {
  const updateExpressions = Object.keys(updateData).map(
    (key) => `#${key} = :${key}`
  );
  const ExpressionAttributeNames = Object.keys(updateData).reduce(
    (acc, key) => ({ ...acc, [`#${key}`]: key }),
    {}
  );
  const ExpressionAttributeValues = Object.keys(updateData).reduce(
    (acc, key) => ({ ...acc, [`:${key}`]: updateData[key as keyof User] }),
    {}
  );
  const { Attributes } = await docClient.send(
    new UpdateCommand({
      TableName: TABLE_NAME,
      Key: { id },
      UpdateExpression: `SET ${updateExpressions.join(", ")}`,
      ExpressionAttributeNames,
      ExpressionAttributeValues,
      ReturnValues: "ALL_NEW",
    })
  );
  return Attributes as User;
};
export const deleteUser = async (id: string): Promise<void> => {
  await docClient.send(
    new DeleteCommand({
      TableName: TABLE_NAME,
      Key: { id },
    })
  );
};
export const listUsers = async (): Promise<User[]> => {
  const result = await docClient.send(
    new ScanCommand({
      TableName: TABLE_NAME,
    })
  );
  return result.Items as User[];
};

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/types/conductor.ts
export interface Conductor {
  id: string;
  Usuario_ID: string;
  Foto_DNI?: string | null;
  Foto_VTV?: string | null;
  Estado: "Pendiente" | "Aprobado" | "Rechazado";
  Vendedor_ID?: string | null;
}

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/types/minibus.ts
export interface Minibus {
  id: string;
  usuario_ID: string;
  marca: string;
  modelo: string;
  a√±o: number;
  patente: string;
  foto_DNI?: string | null;
  foto_VTV?: string | null;
  estado: "Pendiente" | "Aprobado" | "Rechazado";
  vendedor_ID?: string | null;
}

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/types/user.ts
import { UserCredentials } from "./userCredentials";
export interface User {
  id: string;
  credentials: UserCredentials;
  rol: "Conductor" | "Vendedor" | "Administrador";
  estado: "Activo" | "Inactivo" | "Pendiente";
  fechaCreacion: string;
  ultimaActualizacion?: string;
}

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/types/userCredentials.ts
export interface UserCredentials {
  username: string;
  email: string;
  password: string;
  hashedPassword: string;
  telegram?: string;
  telefono?: string;
}

/**********/

