// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/cdk.json
{
  "app": "npx ts-node --prefer-ts-exts src/bin/minibus-backend-aws-cdk.ts",
  "watch": {
    "include": ["**"],
    "exclude": [
      "README.md",
      "cdk*.json",
      "***.js",
      "tsconfig.json",
      "package*.json",
      "yarn.lock",
      "node_modules",
      "test"
    ]
  },
  "context": {
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/core:checkSecretUsage": true,
    "@aws-cdk/core:target-partitions": ["aws", "aws-cn"],
    "@aws-cdk-containers/ecs-service-extensions:enableDefaultLogDriver": true,
    "@aws-cdk/aws-ec2:uniqueImdsv2TemplateName": true,
    "@aws-cdk/aws-ecs:arnFormatIncludesClusterName": true,
    "@aws-cdk/aws-iam:minimizePolicies": true,
    "@aws-cdk/core:validateSnapshotRemovalPolicy": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeyAliasStackSafeResourceName": true,
    "@aws-cdk/aws-s3:createDefaultLoggingPolicy": true,
    "@aws-cdk/aws-sns-subscriptions:restrictSqsDescryption": true,
    "@aws-cdk/aws-apigateway:disableCloudWatchRole": true,
    "@aws-cdk/core:enablePartitionLiterals": true,
    "@aws-cdk/aws-events:eventsTargetQueueSameAccount": true,
    "@aws-cdk/aws-ecs:disableExplicitDeploymentControllerForCircuitBreaker": true,
    "@aws-cdk/aws-iam:importedRoleStackSafeDefaultPolicyName": true,
    "@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy": true,
    "@aws-cdk/aws-route53-patters:useCertificate": true,
    "@aws-cdk/customresources:installLatestAwsSdkDefault": false,
    "@aws-cdk/aws-rds:databaseProxyUniqueResourceName": true,
    "@aws-cdk/aws-codedeploy:removeAlarmsFromDeploymentGroup": true,
    "@aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId": true,
    "@aws-cdk/aws-ec2:launchTemplateDefaultUserData": true,
    "@aws-cdk/aws-secretsmanager:useAttachedSecretResourcePolicyForSecretTargetAttachments": true,
    "@aws-cdk/aws-redshift:columnId": true,
    "@aws-cdk/aws-stepfunctions-tasks:enableEmrServicePolicyV2": true,
    "@aws-cdk/aws-ec2:restrictDefaultSecurityGroup": true,
    "@aws-cdk/aws-apigateway:requestValidatorUniqueId": true,
    "@aws-cdk/aws-kms:aliasNameRef": true,
    "@aws-cdk/aws-autoscaling:generateLaunchTemplateInsteadOfLaunchConfig": true,
    "@aws-cdk/core:includePrefixInUniqueNameGeneration": true,
    "@aws-cdk/aws-efs:denyAnonymousAccess": true,
    "@aws-cdk/aws-opensearchservice:enableOpensearchMultiAzWithStandby": true,
    "@aws-cdk/aws-lambda-nodejs:useLatestRuntimeVersion": true,
    "@aws-cdk/aws-efs:mountTargetOrderInsensitiveLogicalId": true,
    "@aws-cdk/aws-rds:auroraClusterChangeScopeOfInstanceParameterGroupWithEachParameters": true,
    "@aws-cdk/aws-appsync:useArnForSourceApiAssociationIdentifier": true,
    "@aws-cdk/aws-rds:preventRenderingDeprecatedCredentials": true,
    "@aws-cdk/aws-codepipeline-actions:useNewDefaultBranchForCodeCommitSource": true,
    "@aws-cdk/aws-cloudwatch-actions:changeLambdaPermissionLogicalIdForLambdaAction": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeysDefaultValueToFalse": true,
    "@aws-cdk/aws-codepipeline:defaultPipelineTypeToV2": true,
    "@aws-cdk/aws-kms:reduceCrossAccountRegionPolicyScope": true,
    "@aws-cdk/aws-eks:nodegroupNameAttribute": true,
    "@aws-cdk/aws-ec2:ebsDefaultGp3Volume": true,
    "@aws-cdk/aws-ecs:removeDefaultDeploymentAlarm": true,
    "@aws-cdk/custom-resources:logApiResponseDataPropertyTrueDefault": false,
    "@aws-cdk/aws-s3:keepNotificationInImportedBucket": false,
    "@aws-cdk/aws-ecs:enableImdsBlockingDeprecatedFeature": false,
    "@aws-cdk/aws-ecs:disableEcsImdsBlocking": true,
    "@aws-cdk/aws-ecs:reduceEc2FargateCloudWatchPermissions": true,
    "@aws-cdk/aws-dynamodb:resourcePolicyPerReplica": true,
    "@aws-cdk/aws-ec2:ec2SumTImeoutEnabled": true,
    "@aws-cdk/aws-appsync:appSyncGraphQLAPIScopeLambdaPermission": true,
    "@aws-cdk/aws-rds:setCorrectValueForDatabaseInstanceReadReplicaInstanceResourceId": true,
    "@aws-cdk/core:cfnIncludeRejectComplexResourceUpdateCreatePolicyIntrinsics": true,
    "@aws-cdk/aws-lambda-nodejs:sdkV3ExcludeSmithyPackages": true,
    "@aws-cdk/aws-stepfunctions-tasks:fixRunEcsTaskPolicy": true,
    "@aws-cdk/aws-ec2:bastionHostUseAmazonLinux2023ByDefault": true,
    "@aws-cdk/aws-route53-targets:userPoolDomainNameMethodWithoutCustomResource": true,
    "@aws-cdk/aws-elasticloadbalancingV2:albDualstackWithoutPublicIpv4SecurityGroupRulesDefault": true,
    "@aws-cdk/aws-iam:oidcRejectUnauthorizedConnections": true,
    "@aws-cdk/core:enableAdditionalMetadataCollection": true
  }
}

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/handlers/auth.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import { createUser, listUsers } from "../models/userModel";
const bcrypt = require("bcryptjs");
import * as jwt from "jsonwebtoken";
const USERS_TABLE = process.env.USERS_TABLE || "Users";
const JWT_SECRET = process.env.JWT_SECRET || "your_jwt_secret";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const path = event.path.toLowerCase();
  if (event.httpMethod !== "POST") {
    return {
      statusCode: 405,
      body: JSON.stringify({ message: "Método no permitido" }),
    };
  }
  try {
    if (path.endsWith("sign-up")) {
      if (!event.body) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "Cuerpo de solicitud faltante" }),
        };
      }
      const data = JSON.parse(event.body);
      const { username, email, password, telegram, telefono } = data;
      if (!username || !email || !password) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "Faltan campos obligatorios" }),
        };
      }
      const users = await listUsers();
      const existingUser = users.find(
        (u) =>
          u.credentials.email.toLowerCase() === email.toLowerCase() ||
          u.credentials.username.toLowerCase() === username.toLowerCase()
      );
      if (existingUser) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "El usuario ya existe" }),
        };
      }
      const hashedPassword = await bcrypt.hash(password, 10);
      const newUser = await createUser({
        credentials: {
          username,
          email,
          password: "", 
          hashedPassword,
          telegram: telegram || "",
          telefono: telefono || "",
        },
        rol: "Conductor", 
        estado: "Pendiente",
        fechaCreacion: new Date().toISOString(),
      });
      return {
        statusCode: 201,
        body: JSON.stringify({
          message: "Usuario creado exitosamente",
          user: newUser,
        }),
      };
    } else if (path.endsWith("log-in")) {
      if (!event.body) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "Cuerpo de solicitud faltante" }),
        };
      }
      const data = JSON.parse(event.body);
      const { email, password } = data;
      if (!email || !password) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "Faltan campos obligatorios" }),
        };
      }
      const users = await listUsers();
      const user = users.find(
        (u) => u.credentials.email.toLowerCase() === email.toLowerCase()
      );
      if (!user) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "Credenciales inválidas" }),
        };
      }
      const validPassword = await bcrypt.compare(
        password,
        user.credentials.hashedPassword
      );
      if (!validPassword) {
        return {
          statusCode: 400,
          body: JSON.stringify({ message: "Credenciales inválidas" }),
        };
      }
      const token = jwt.sign(
        { id: user.id, email: user.credentials.email, rol: user.rol },
        JWT_SECRET,
        { expiresIn: "1h" }
      );
      return {
        statusCode: 200,
        body: JSON.stringify({ message: "Log in exitoso", token }),
      };
    } else if (path.endsWith("log-out")) {
      return {
        statusCode: 200,
        body: JSON.stringify({ message: "Log out exitoso" }),
      };
    } else {
      return {
        statusCode: 404,
        body: JSON.stringify({ message: "Ruta no encontrada" }),
      };
    }
  } catch (error: any) {
    console.error("Error en auth handler:", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno", error: error.message }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/handlers/conductores.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import * as jwt from "jsonwebtoken";
import {
  createConductor,
  getConductor,
  updateConductor,
  deleteConductor,
  listConductores,
} from "../models/conductorModel";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const { httpMethod, pathParameters, body } = event;
  const authHeader = event.headers.Authorization || event.headers.authorization;
  if (!authHeader) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: falta el token" }),
    };
  }
  const token = authHeader.split(" ")[1]; 
  if (!token) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token mal formado" }),
    };
  }
  try {
    const secret = process.env.JWT_SECRET;
    if (!secret) {
      throw new Error("JWT_SECRET is not defined");
    }
    jwt.verify(token, secret);
  } catch (err) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token inválido" }),
    };
  }
  try {
    switch (httpMethod) {
      case "GET":
        if (pathParameters?.id) {
          const conductor = await getConductor(pathParameters.id);
          if (!conductor) {
            return {
              statusCode: 404,
              body: JSON.stringify({ message: "Conductor no encontrado" }),
            };
          }
          return { statusCode: 200, body: JSON.stringify(conductor) };
        } else {
          const conductores = await listConductores();
          return { statusCode: 200, body: JSON.stringify(conductores) };
        }
      case "POST":
        if (!body) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "Falta el cuerpo de la solicitud",
            }),
          };
        }
        const data = JSON.parse(body);
        if (!data.Usuario_ID) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Usuario_ID es obligatorio" }),
          };
        }
        const newConductor = await createConductor(data);
        return { statusCode: 201, body: JSON.stringify(newConductor) };
      case "PUT":
        if (!pathParameters?.id || !body) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "Falta el ID o el cuerpo de la solicitud",
            }),
          };
        }
        const updateData = JSON.parse(body);
        const updatedConductor = await updateConductor(
          pathParameters.id,
          updateData
        );
        return { statusCode: 200, body: JSON.stringify(updatedConductor) };
      case "DELETE":
        if (!pathParameters?.id) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Falta el ID en la ruta" }),
          };
        }
        await deleteConductor(pathParameters.id);
        return { statusCode: 204, body: "" };
      default:
        return {
          statusCode: 405,
          body: JSON.stringify({ message: "Método no permitido" }),
        };
    }
  } catch (error: any) {
    console.error("Error:", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno", error: error.message }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/handlers/paradas.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import * as jwt from "jsonwebtoken";
import {
  createParada,
  getParada,
  updateParada,
  deleteParada,
  listParadas,
} from "../models/paradaModel";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const { httpMethod, pathParameters, body } = event;
  const authHeader = event.headers.Authorization || event.headers.authorization;
  if (!authHeader) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: falta el token" }),
    };
  }
  const token = authHeader.split(" ")[1]; 
  if (!token) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token mal formado" }),
    };
  }
  try {
    const secret = process.env.JWT_SECRET;
    if (!secret) {
      throw new Error("JWT_SECRET is not defined");
    }
    jwt.verify(token, secret);
  } catch (err) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token inválido" }),
    };
  }
  try {
    switch (httpMethod) {
      case "GET":
        if (pathParameters?.id) {
          const parada = await getParada(pathParameters.id);
          if (!parada) {
            return {
              statusCode: 404,
              body: JSON.stringify({ message: "Parada no encontrada" }),
            };
          }
          return { statusCode: 200, body: JSON.stringify(parada) };
        } else {
          const paradas = await listParadas();
          return { statusCode: 200, body: JSON.stringify(paradas) };
        }
      case "POST":
        if (!body) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "Falta el cuerpo de la solicitud",
            }),
          };
        }
        const data = JSON.parse(body);
        if (
          !data.nombre ||
          !data.descripcion ||
          !data.calle ||
          !data.numero ||
          !data.localidad ||
          !data.codigoPostal ||
          !data.partido ||
          !data.provincia
        ) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message:
                "Faltan campos requeridos: nombre, descripcion, calle, numero, localidad, codigoPostal, partido, provincia",
            }),
          };
        }
        const newParada = await createParada(data);
        return { statusCode: 201, body: JSON.stringify(newParada) };
      case "PUT":
        if (!pathParameters?.id || !body) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "Falta el ID o el cuerpo de la solicitud",
            }),
          };
        }
        const updateData = JSON.parse(body);
        const updatedParada = await updateParada(pathParameters.id, updateData);
        return { statusCode: 200, body: JSON.stringify(updatedParada) };
      case "DELETE":
        if (!pathParameters?.id) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Falta el ID en la ruta" }),
          };
        }
        await deleteParada(pathParameters.id);
        return { statusCode: 204, body: "" };
      default:
        return {
          statusCode: 405,
          body: JSON.stringify({ message: "Método no permitido" }),
        };
    }
  } catch (error: any) {
    console.error("Error:", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno", error: error.message }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/handlers/paradasDeRuta.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import * as jwt from "jsonwebtoken";
import {
  createParadaDeRuta,
  getParadaDeRuta,
  updateParadaDeRuta,
  deleteParadaDeRuta,
  listParadasDeRuta,
} from "../models/paradaDeRuta";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const { httpMethod, pathParameters, body } = event;
  const authHeader = event.headers.Authorization || event.headers.authorization;
  if (!authHeader) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: falta el token" }),
    };
  }
  const token = authHeader.split(" ")[1]; 
  if (!token) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token mal formado" }),
    };
  }
  try {
    const secret = process.env.JWT_SECRET;
    if (!secret) {
      throw new Error("JWT_SECRET is not defined");
    }
    jwt.verify(token, secret);
  } catch (err) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token inválido" }),
    };
  }
  try {
    switch (httpMethod) {
      case "GET":
        if (pathParameters?.id) {
          const paradaDeRuta = await getParadaDeRuta(pathParameters.id);
          if (!paradaDeRuta) {
            return {
              statusCode: 404,
              body: JSON.stringify({ message: "Parada de ruta no encontrada" }),
            };
          }
          return { statusCode: 200, body: JSON.stringify(paradaDeRuta) };
        } else {
          const paradasDeRuta = await listParadasDeRuta();
          return { statusCode: 200, body: JSON.stringify(paradasDeRuta) };
        }
      case "POST":
        if (!body) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "Falta el cuerpo de la solicitud",
            }),
          };
        }
        const data = JSON.parse(body);
        if (!data.parada || data.posicion === undefined || !data.horario) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "Faltan campos requeridos: parada, posicion y horario",
            }),
          };
        }
        const newParadaDeRuta = await createParadaDeRuta(data);
        return { statusCode: 201, body: JSON.stringify(newParadaDeRuta) };
      case "PUT":
        if (!pathParameters?.id || !body) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "Falta el ID o el cuerpo de la solicitud",
            }),
          };
        }
        const updateData = JSON.parse(body);
        const updatedParadaDeRuta = await updateParadaDeRuta(
          pathParameters.id,
          updateData
        );
        return { statusCode: 200, body: JSON.stringify(updatedParadaDeRuta) };
      case "DELETE":
        if (!pathParameters?.id) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Falta el ID en la ruta" }),
          };
        }
        await deleteParadaDeRuta(pathParameters.id);
        return { statusCode: 204, body: "" };
      default:
        return {
          statusCode: 405,
          body: JSON.stringify({ message: "Método no permitido" }),
        };
    }
  } catch (error: any) {
    console.error("Error:", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno", error: error.message }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/handlers/rutas.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import * as jwt from "jsonwebtoken";
import {
  createRuta,
  getRuta,
  updateRuta,
  deleteRuta,
  listRutas,
} from "../models/rutaModel";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const { httpMethod, pathParameters, body } = event;
  const authHeader = event.headers.Authorization || event.headers.authorization;
  if (!authHeader) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: falta el token" }),
    };
  }
  const token = authHeader.split(" ")[1]; 
  if (!token) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token mal formado" }),
    };
  }
  try {
    const secret = process.env.JWT_SECRET;
    if (!secret) {
      throw new Error("JWT_SECRET is not defined");
    }
    jwt.verify(token, secret);
  } catch (err) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token inválido" }),
    };
  }
  try {
    switch (httpMethod) {
      case "GET":
        if (pathParameters?.id) {
          const ruta = await getRuta(pathParameters.id);
          if (!ruta) {
            return {
              statusCode: 404,
              body: JSON.stringify({ message: "Ruta no encontrada" }),
            };
          }
          return { statusCode: 200, body: JSON.stringify(ruta) };
        } else {
          const rutas = await listRutas();
          return { statusCode: 200, body: JSON.stringify(rutas) };
        }
      case "POST":
        if (!body) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Cuerpo de solicitud faltante" }),
          };
        }
        const data = JSON.parse(body);
        if (!data.conductorId || !data.paradasDeRuta) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "Faltan campos requeridos: conductorId y paradasDeRuta",
            }),
          };
        }
        const newRuta = await createRuta({
          conductorId: data.conductorId,
          estado: data.estado || "activa",
          paradasDeRuta: data.paradasDeRuta,
          createdAt: new Date().toISOString(),
        });
        return { statusCode: 201, body: JSON.stringify(newRuta) };
      case "PUT":
        if (!pathParameters?.id || !body) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "ID o cuerpo de solicitud faltante",
            }),
          };
        }
        const updateData = JSON.parse(body);
        const updatedRuta = await updateRuta(pathParameters.id, updateData);
        return { statusCode: 200, body: JSON.stringify(updatedRuta) };
      case "DELETE":
        if (!pathParameters?.id) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "ID faltante" }),
          };
        }
        await deleteRuta(pathParameters.id);
        return { statusCode: 204, body: "" };
      default:
        return {
          statusCode: 405,
          body: JSON.stringify({ message: "Método no permitido" }),
        };
    }
  } catch (error: any) {
    console.error("Error:", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno", error: error.message }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/handlers/usuarios.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import * as jwt from "jsonwebtoken";
import {
  createUser,
  getUser,
  updateUser,
  deleteUser,
  listUsers,
} from "../models/userModel";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const { httpMethod, pathParameters, body } = event;
  const authHeader = event.headers.Authorization || event.headers.authorization;
  if (!authHeader) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: falta el token" }),
    };
  }
  const token = authHeader.split(" ")[1]; 
  if (!token) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token mal formado" }),
    };
  }
  try {
    const secret = process.env.JWT_SECRET;
    if (!secret) {
      throw new Error("JWT_SECRET is not defined");
    }
    jwt.verify(token, secret);
  } catch (err) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token inválido" }),
    };
  }
  try {
    switch (httpMethod) {
      case "GET":
        if (pathParameters?.id) {
          const user = await getUser(pathParameters.id);
          return user
            ? { statusCode: 200, body: JSON.stringify(user) }
            : {
                statusCode: 404,
                body: JSON.stringify({ message: "Usuario no encontrado" }),
              };
        } else {
          const users = await listUsers();
          return { statusCode: 200, body: JSON.stringify(users) };
        }
      case "POST":
        if (!body) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Cuerpo de solicitud faltante" }),
          };
        }
        const newUser = await createUser(JSON.parse(body));
        return { statusCode: 201, body: JSON.stringify(newUser) };
      case "PUT":
        if (!pathParameters?.id || !body) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Falta ID o cuerpo de solicitud" }),
          };
        }
        const updatedUser = await updateUser(
          pathParameters.id,
          JSON.parse(body)
        );
        return { statusCode: 200, body: JSON.stringify(updatedUser) };
      case "DELETE":
        if (!pathParameters?.id) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Falta ID en la ruta" }),
          };
        }
        await deleteUser(pathParameters.id);
        return { statusCode: 204, body: "" };
      default:
        return {
          statusCode: 405,
          body: JSON.stringify({ message: "Método no permitido" }),
        };
    }
  } catch (error: any) {
    console.error("Error:", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno", error: error.message }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/handlers/viajes.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import {
  createViaje,
  getViaje,
  updateViaje,
  deleteViaje,
  listViajes,
  getViajesPorRuta,
  getViajesPorConductor,
} from "../models/viajeModel";
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const { httpMethod, pathParameters, body, queryStringParameters } = event;
  const authHeader = event.headers.Authorization || event.headers.authorization;
  if (!authHeader) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: falta el token" }),
    };
  }
  const token = authHeader.split(" ")[1]; 
  if (!token) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token mal formado" }),
    };
  }
  try {
    const secret = process.env.JWT_SECRET;
    if (!secret) {
      throw new Error("JWT_SECRET is not defined");
    }
    jwt.verify(token, secret);
  } catch (err) {
    return {
      statusCode: 401,
      body: JSON.stringify({ message: "No autorizado: token inválido" }),
    };
  }
  try {
    switch (httpMethod) {
      case "GET":
        if (event.queryStringParameters?.conductorId) {
          const viajes = await getViajesPorConductor(
            event.queryStringParameters.conductorId
          );
          return { statusCode: 200, body: JSON.stringify(viajes) };
        }
        if (queryStringParameters?.rutaId) {
          const viajes = await getViajesPorRuta(queryStringParameters.rutaId);
          return { statusCode: 200, body: JSON.stringify(viajes) };
        }
        if (pathParameters?.id) {
          const viaje = await getViaje(pathParameters.id);
          if (!viaje) {
            return {
              statusCode: 404,
              body: JSON.stringify({ message: "Viaje no encontrado" }),
            };
          }
          return { statusCode: 200, body: JSON.stringify(viaje) };
        } else {
          const viajes = await listViajes();
          return { statusCode: 200, body: JSON.stringify(viajes) };
        }
      case "POST":
        if (!body) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "Cuerpo de solicitud faltante" }),
          };
        }
        const data = JSON.parse(body);
        if (!data.rutaId || !data.conductorId || !data.paradasDeRuta) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message:
                "Faltan campos requeridos: rutaId, conductorId, paradasDeRuta",
            }),
          };
        }
        const newViaje = await createViaje({
          ...data,
          estado: data.estado || "programado",
          fechaInicio: new Date().toISOString(),
        });
        return { statusCode: 201, body: JSON.stringify(newViaje) };
      case "PUT":
        if (!pathParameters?.id || !body) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "ID o cuerpo de solicitud faltante",
            }),
          };
        }
        const updateData = JSON.parse(body);
        if (
          updateData.paradasDeRuta &&
          !Array.isArray(updateData.paradasDeRuta)
        ) {
          return {
            statusCode: 400,
            body: JSON.stringify({
              message: "paradasDeRuta debe ser un array",
            }),
          };
        }
        const updatedViaje = await updateViaje(pathParameters.id, updateData);
        return { statusCode: 200, body: JSON.stringify(updatedViaje) };
      case "DELETE":
        if (!pathParameters?.id) {
          return {
            statusCode: 400,
            body: JSON.stringify({ message: "ID faltante" }),
          };
        }
        await deleteViaje(pathParameters.id);
        return { statusCode: 204, body: "" };
      default:
        return {
          statusCode: 405,
          body: JSON.stringify({ message: "Método no permitido" }),
        };
    }
  } catch (error: any) {
    console.error("Error:", error);
    return {
      statusCode: 500,
      body: JSON.stringify({ message: "Error interno", error: error.message }),
    };
  }
};

/**********/

// File: /Users/matiaskochman/dev/personal/vercel_ex/minibus-backend-aws-cdk/src/lib/handlers-construct.ts
import * as cdk from "aws-cdk-lib";
import { Construct } from "constructs";
import * as lambda from "aws-cdk-lib/aws-lambda";
import * as lambdaNode from "aws-cdk-lib/aws-lambda-nodejs";
import * as path from "path";
import * as dynamodb from "aws-cdk-lib/aws-dynamodb";
interface HandlersConstructProps {
  driversTable: dynamodb.Table;
  routesTable: dynamodb.Table;
  paradasTable: dynamodb.Table;
  paradasDeRutaTable: dynamodb.Table;
  viajesTable: dynamodb.Table;
  usersTable: dynamodb.Table;
}
export class HandlersConstruct extends Construct {
  public readonly conductoresHandler: lambdaNode.NodejsFunction;
  public readonly rutasHandler: lambdaNode.NodejsFunction;
  public readonly paradasHandler: lambdaNode.NodejsFunction;
  public readonly paradasDeRutaHandler: lambdaNode.NodejsFunction;
  public readonly viajesHandler: lambdaNode.NodejsFunction;
  public readonly usuariosHandler: lambdaNode.NodejsFunction;
  public readonly authHandler: lambdaNode.NodejsFunction;
  constructor(scope: Construct, id: string, props: HandlersConstructProps) {
    super(scope, id);
    this.conductoresHandler = new lambdaNode.NodejsFunction(
      this,
      "ConductoresHandler",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../handlers/conductores.ts"),
        handler: "handler",
        environment: {
          USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
          CONDUCTORES_TABLE: props.driversTable.tableName,
          JWT_SECRET: process.env.JWT_SECRET as string, 
        },
        bundling: { externalModules: ["@aws-sdk"] },
      }
    );
    this.rutasHandler = new lambdaNode.NodejsFunction(this, "RutasHandler", {
      runtime: lambda.Runtime.NODEJS_18_X,
      entry: path.join(__dirname, "../handlers/rutas.ts"),
      handler: "handler",
      environment: {
        USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
        RUTAS_TABLE: props.routesTable.tableName,
        JWT_SECRET: process.env.JWT_SECRET as string, 
      },
      bundling: { externalModules: ["@aws-sdk"] },
    });
    this.paradasHandler = new lambdaNode.NodejsFunction(
      this,
      "ParadasHandler",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../handlers/paradas.ts"),
        handler: "handler",
        environment: {
          USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
          PARADAS_TABLE: props.paradasTable.tableName,
          JWT_SECRET: process.env.JWT_SECRET as string, 
        },
        bundling: { externalModules: ["@aws-sdk"] },
      }
    );
    this.paradasDeRutaHandler = new lambdaNode.NodejsFunction(
      this,
      "ParadasDeRutaHandler",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../handlers/paradasDeRuta.ts"),
        handler: "handler",
        environment: {
          USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
          PARADAS_TABLE: props.paradasDeRutaTable.tableName,
          JWT_SECRET: process.env.JWT_SECRET as string, 
        },
        bundling: { externalModules: ["@aws-sdk"] },
      }
    );
    this.viajesHandler = new lambdaNode.NodejsFunction(this, "ViajesHandler", {
      runtime: lambda.Runtime.NODEJS_18_X,
      entry: path.join(__dirname, "../handlers/viajes.ts"),
      handler: "handler",
      environment: {
        USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
        TRIPS_TABLE: props.viajesTable.tableName,
        PARADAS_DE_RUTA_TABLE: props.paradasDeRutaTable.tableName, 
        JWT_SECRET: process.env.JWT_SECRET as string, 
      },
      bundling: { externalModules: ["@aws-sdk"] },
    });
    this.usuariosHandler = new lambdaNode.NodejsFunction(
      this,
      "UsuariosHandler",
      {
        runtime: lambda.Runtime.NODEJS_18_X,
        entry: path.join(__dirname, "../handlers/usuarios.ts"),
        handler: "handler",
        environment: {
          USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
          USERS_TABLE: props.usersTable.tableName,
          JWT_SECRET: process.env.JWT_SECRET as string, 
        },
        bundling: { externalModules: ["@aws-sdk"] },
      }
    );
    this.authHandler = new lambdaNode.NodejsFunction(this, "AuthHandler", {
      runtime: lambda.Runtime.NODEJS_18_X,
      entry: path.join(__dirname, "../handlers/auth.ts"),
      handler: "handler",
      environment: {
        USE_LOCALSTACK: process.env.USE_LOCALSTACK || "true",
        USERS_TABLE: props.usersTable.tableName,
        JWT_SECRET: process.env.JWT_SECRET as string,
      },
      bundling: { externalModules: ["@aws-sdk"] },
    });
    props.usersTable.grantReadWriteData(this.usuariosHandler);
    props.viajesTable.grantReadWriteData(this.viajesHandler);
    props.driversTable.grantReadWriteData(this.conductoresHandler);
    props.routesTable.grantReadWriteData(this.rutasHandler);
    props.paradasTable.grantReadWriteData(this.paradasHandler);
    props.paradasDeRutaTable.grantReadWriteData(this.paradasDeRutaHandler);
  }
}

/**********/

